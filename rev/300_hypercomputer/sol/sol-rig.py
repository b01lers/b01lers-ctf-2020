# The problem text suggests "rigging", so try to tweak the binary to do 
# what we need (instead of reversing it completely). In particular, we want
# to feed it with the random number generated by the remote challenge, let
# it compute what we need, then use the result to answer the remote challenge.
#
#
# STEP 1 - First, ltrace logs:
#
#   gettimeofday: 2
#   srand: 1
#   rand: 1
#   sleep: ~O(10)
#   usleep: ~O(300)
#
# In Ghidra we see that there can be at most 1 million microsecs between 
# the two gettimeofday calls, so input must be entered within one second, 
# or else the coordinates are set to "0,0". To deal with timing issues, 
# use LD_PRELOAD to disable sleep, usleep, and have gettimeofday return a 
# fixed time. Also, overwrite rand to take its return value from the file 
# rand_result.dat we control. This way we control the randomly generated 
# frequency and memory values, and later can set those to match the values 
# in the actual remote challenge:
#
#  ifreq = (14. - freq) / 5. * 65535
#  imem = (64. - mem) / 50. * 65535
#  rand = (imem - 0x8000) << 16 + (ifreq - 0x10000) 
#
# It is advisable to round ifreq and imem before computing rand.
#
# So we preload my_lib.so (compiled from my_lib.c), automated via 
# the script run.scr that takes the name of the executable to run 
# as its parameter:
#
#   run.scr hypercomputer-SIM
#
#
# --
#
# STEP 2 - The input is of the form "x,y", which values are then compared 
# to some expectation based on the random value rand generated. There are 
# lots of unknown functions that build up those expected results, some of 
# which are used several times. Most of these functions get a pointer to
# the tpStruct variable passed to them. Luckily, running strings suggests 
# that there is some test code left in the binary, in fact, the TESTall 
# symbol is still in the binary. With Ghidra, one finds the following 
# functions:
#
#   00101be8  MAIN
#   00101a95  function (=FX) that computes the expected 'x' value (edi=ifreq, esi=imem, rdx=ptr to tpStruct)
#   00101b1e  function (=FY) that computes the expected 'y' value (edi=ifreq, esi=imem, rdx=ptr to tpStruct) 
#   00101a35  TESTall: dead code that looks like a collection of tests (rdi=ptr to tpStruct)
#
#   00100b74  test +           -> a+b?
#   00101216  test sum?        -> sum numbers up to n?
#   0010123f  test "mod2"      -> mod 2?
#   00101305  test "!=0"       -> nonzero check?
#   001013cb  test "a-b=%d"    -> subtract a-b?
#   001014cd  test (%d/2)=     -> div by 2?
#   00101593  test "sum(..)"   -> sum an array of numbers?
#   0010166f  test "a-b=%d"    -> another subtract??
#   001017ef  test "cmp(a,b)=" -> compare?
#   0010196f  test "(%d*2)="   -> multiply by 2 ?
#
# TESTall takes one parameter, which is then passed down to each function,
# and within those to all subfunctions etc, so it must be a pointer to tpStruct.
# We hijack the call to FX at 0x101dc4 to call TESTall instead:
#
#   00101dc0   89 de            MOV ESI,EBX
#   00101dc2   89 ef            MOV EDI,...
#   00101dc4   e8 cc fc ff ff   CALL 101a95    (rel jump rip+0xfffffccc)
# 
# which we change to
#
#   00101dc0   48 89 d7         MOV RDI,RDX    (need &tpStruct in RDI)
#   00101dc3   90               NOP
#   00101dc4   e8 6c fc ff ff   CALL 101a35
#
# and save it into the file hyp0.
#

import os

def patch(code, pos, p):
   code[pos:(pos + len(p))] = p


with open("hypercomputer-SIM", "rb") as f:
   binary = f.read()

binary0 = bytearray(binary)
patch(binary0, 0x1dc0, b"\x48\x89\xd7\x90")
binary0[0x1dc5] = 0x6c

with open("hyp0", "wb") as f:
   f.write(binary0)

os.system("chmod +x hyp0")
#os.system("run.scr hyp0")       #disable after exploration


#
# Running the test (run.scr hyp0) prints:
#
# c=40
# 1111111111111111111111111111111111111111011111111111111111111111111111100000000000000000000000000000
# 1111111111111111111111111111111111111111011111111111111111111111111111100000000000000000000000000000
# 40+30=70
# 1111111111111111111111111111111111111111111111111111111111111111111111000000000000000000000000000000
# 0+30=30
# 1111111111111111111111111111110011111111111111111111111111111111111111000000000000000000000000000000
# 30+0=30
# 1111111111111111111111111111110011111111111111111111111111111111111111000000000000000000000000000000
# 0+0=0
# 0011111111111111111111111111110011111111111111111111111111111111111111000000000000000000000000000000
# sum(125)=7875
# mod2(0)=0,  mod2(1)=1,  mod2(2)=0,  mod2(5)=1,  mod2(10)=0
# (0!=0)=0,  (1!=0)=1,  (2!=0)=1,  (5!=0)=1,  (10!=0)=1
# 20-20=0, 20-0=20, 20-19=1, 0-0=0, 1-1=0, 1-0=1
# (0/2)=0,  (1/2)=0,  (2/2)=1,  (5/2)=2,  (10/2)=5
# sum(1,2,5,10)=18
# sum(32,11,1,18,7,20,3)=92
# 20-20=0, 20-0=20, 20-19=1, 0-0=0, 1-1=0, 1-0=1
# 0-20=0, 19-20=0, 0-1=0
# cmp(20,20)=0, cmp(20,0)=1, cmp(20,19)=1, cmp(0,0)=0, cmp(1,1)=0, cmp(1,0)=1
# cmp(0,20)=2, cmp(19,20)=2, cmp(0,1)=2
# (0*2)=0,  (1*2)=2,  (2*2)=4,  (5*2)=10,  (10*2)=20
#
# So we can see that
#
# => nonzero(a) returns 0 if false, 1 if true
# => first sub(a,b) function is only tested with a>=b, and returns a-b
# => second sub(a,b) function returns 0 when a < b, otherwise a - b
# => cmp(a,b) = 0,1,2 on equal, a>b, b>a
# => div 2, mod 2, sum, mul 2 all work as expected (div 2 rounds down)
#
# ---
#
# STEP 3 - Notice that the actual coordinate validation is MUCH slower in 
# the simulator than in the actual challenge. While we do not know the 
# reason, we can edit the values used in the tests to gauge simulator 
# performance. For example, we can sum numbers up to O(1000) instead of 
# just 125... to find a massive slowdown. hyp1 sums up to 2048, evaluates 
# mod2() and nonzero() on 8192 instead of 0, and subtracts 32768-32768 
# instead of 20-20.
#

binary1 = binary0
patch(binary1, 0x1a47, (2048).to_bytes(2, byteorder = 'little'))
patch(binary1, 0x125f, (8192).to_bytes(2, byteorder = 'little'))
patch(binary1, 0x1325, (8192).to_bytes(2, byteorder = 'little'))
patch(binary1, 0x13d3, (32768).to_bytes(2, byteorder = 'little'))
patch(binary1, 0x13d8, (32768).to_bytes(2, byteorder = 'little'))

with open("hyp1", "wb") as f:
   f.write(binary1)

os.system("chmod +x hyp1")
#os.system("run.scr hyp1")       #disable after exploration



#---
#
# STEP 4 - replace the basic functions with faster equivalents. This only 
# needs very little code, and we have plenty of room to fit things in.
#
# add(edi=a,esi=b)  at 0x100dd6, retval in eax
# sub(edi=a,esi=b)  at 0x100df8, retval in eax
# sub0(edi=a,esi=b) at 0x100e1a, retval in eax   [a-b if a>=b, 0 if b > a]
# div2(rdi=a)       at 0x100e85, retval in eax
# nonzero(rdi=a)    at 0x100ef5, retval in eax
#

from keystone import *
ks = Ks(KS_ARCH_X86, KS_MODE_64)

code1 = (b"mov rax,rdi\n"          # fast a+b
         b"add rax,rsi\n"
         b"ret"   )
bytes1 = bytes(ks.asm(code1)[0])   #b"\x48\x89\xf8\x48\x01\xf0\xc3"

code2 = (b"mov eax,edi\n"          # fast a-b
         b"sub eax,esi\n"
         b"ret"  )
bytes2 = bytes(ks.asm(code2)[0])   #b"\x89\xf8\x29\xf0\xc3"

code3 = (b"mov eax,edi\n"          # fast a-b if a>=b, 0 if a<b
         b"cmp eax,esi\n"
         b"jg label\n"
         b"xor eax,eax\n"
         b"ret\n"
         b"label:   sub eax,esi\n"
         b"ret"  )
bytes3 = bytes(ks.asm(code3)[0])   #b"\x89\xf8\x39\xf0\x7f\x03\x31\xc0\xc3\x29\xf0\xc3"

code4 = (b"mov rax,rdi\n"          # fast div 2
         b"shr rax,1\n"
         b"ret"  )
bytes4 = bytes(ks.asm(code4)[0])   #b"\x48\x89\xf8\x48\xd1\xe8\xc3"

code5 = (b"mov rax,rdi\n"          # fast nonzero
         b"test rax,rax\n"
         b"je label\n"
         b"mov rax,1\n"
         b"label:  ret"  )
bytes5 = bytes(ks.asm(code5)[0])   #b"\x48\x89\xf8\x48\x85\xc0\x74\x05\xb8\x01\x00\x00\x00\xc3")  

binary2 = bytearray(binary)       # patch original
#binary2 = bytearray(binary1)      # or patch hyp1 to verify that TESTall runs faster and correctly

patch(binary2, 0x0dd6, bytes1)   
patch(binary2, 0x0df8, bytes2)
patch(binary2, 0x0e1a, bytes3)
patch(binary2, 0x0e85, bytes4)
patch(binary2, 0x0ef5, bytes5)


with open("hyp2", "wb") as f:
   f.write(binary2)

os.system("chmod +x hyp2")
#os.system("run.scr hyp2")   # disable after exploration


#---
#
# STEP 5 - now we have everything, except getting those expected values 
# out from the code. => Use gdb script.
#

os.system("echo 12345678 > rand_result.dat")
#os.system("echo '1,1' | gdb -batch -x gdb_step5.gscr hyp2")   # disable after exploration

# i.e., x,y = 920164,78179 print the flag if rand=12345678
#
# test it:
#os.system("echo '920164,78179' | run.scr hyp2")      # disable after exploration


#---
#
# STEP 6 - FINALLY, solve the challenge. Connect to the remote, get freq/mem, 
# compute the corresponding rand value and write it into ran_result.dat. 
# Then run the rigged simulator, get the expected (x,y), and feed those to 
# the remote.
# 

from pwn import *

r = remote("localhost", 13370)

in1 = r.recvuntil("coordinates").split(b" ")
#print(in1)
freq = float(in1[-13])
mem = float(in1[-9])

#print(freq, mem)
ifreq = int((14. - freq) / 5. * 65535 + 0.5)
imem = int((64. - mem) / 50. * 65535 + 0.5)
#print(ifreq, imem)
rand = ((imem - 0x8000) << 16) + (ifreq - 0x10000) 

#print(rand)
with open("rand_result.dat", "w") as f:
   f.write(str(rand))


in2 = os.popen("echo '1,1' | gdb -batch -x gdb_step5.gscr hyp2").read()
in2 = in2.split("\n")
out2 = in2[10].split()[-1] + "," + in2[11].split()[-1]
print(out2)
r.send(out2 + "\n")
print(str(r.recvall(), "ascii"))



#===
