{"version":3,"file":"popper.min.js","sources":["../../src/dom-utils/getBoundingClientRect.js","../../src/dom-utils/getWindow.js","../../src/dom-utils/getWindowScroll.js","../../src/dom-utils/instanceOf.js","../../src/dom-utils/getNodeName.js","../../src/dom-utils/getComputedStyle.js","../../src/dom-utils/getBorders.js","../../src/dom-utils/getCompositeRect.js","../../src/dom-utils/getNodeScroll.js","../../src/dom-utils/getHTMLElementScroll.js","../../src/dom-utils/getLayoutRect.js","../../src/dom-utils/getParentNode.js","../../src/dom-utils/listScrollParents.js","../../src/dom-utils/getScrollParent.js","../../src/dom-utils/getOffsetParent.js","../../src/dom-utils/isTableElement.js","../../src/utils/orderModifiers.js","../../src/utils/debounce.js","../../src/utils/getBasePlacement.js","../../src/index.js","../../src/utils/getMainAxisFromPlacement.js","../../src/utils/computeOffsets.js","../../src/utils/getVariation.js","../../src/enums.js","../../src/modifiers/computeStyles.js","../../src/utils/getOppositePlacement.js","../../src/utils/getOppositeVariationPlacement.js","../../src/dom-utils/contains.js","../../src/utils/rectToClientRect.js","../../src/dom-utils/getClippingRect.js","../../src/dom-utils/getViewportRect.js","../../src/dom-utils/getDocumentRect.js","../../src/dom-utils/getDecorations.js","../../src/utils/mergePaddingObject.js","../../src/utils/getFreshSideObject.js","../../src/utils/expandToHashMap.js","../../src/utils/detectOverflow.js","../../src/modifiers/hide.js","../../src/modifiers/eventListeners.js","../../src/popper.js","../../src/modifiers/popperOffsets.js","../../src/modifiers/applyStyles.js","../../src/modifiers/offset.js","../../src/modifiers/flip.js","../../src/utils/uniqueBy.js","../../src/utils/computeAutoPlacement.js","../../src/modifiers/preventOverflow.js","../../src/utils/getAltAxis.js","../../src/utils/within.js","../../src/modifiers/arrow.js"],"sourcesContent":["// @flow\nimport type { ClientRectObject, VirtualElement } from '../types';\n\nexport default function getBoundingClientRect(\n  element: Element | VirtualElement\n): ClientRectObject {\n  const rect = element.getBoundingClientRect();\n\n  return {\n    width: rect.width,\n    height: rect.height,\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    x: rect.left,\n    y: rect.top,\n  };\n}\n","// @flow\n\nexport default function getWindow(node: Node): any {\n  if ({}.toString.call(node) !== '[object Window]') {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView : window;\n  }\n\n  return node;\n}\n","// @flow\nimport getWindow from './getWindow';\n\nexport default function getWindowScroll(node: Node) {\n  const win = getWindow(node);\n  const scrollLeft = win.pageXOffset;\n  const scrollTop = win.pageYOffset;\n\n  return {\n    scrollLeft,\n    scrollTop,\n  };\n}\n","// @flow\nimport getWindow from './getWindow';\n\n/*:: declare function isElement(node: mixed): boolean %checks(node instanceof\n  Element); */\n\nfunction isElement(node) {\n  const OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement;\n}\n\n/*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof\n  HTMLElement); */\n\nfunction isHTMLElement(node) {\n  const OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement;\n}\n\nexport { isElement, isHTMLElement };\n","// @flow\n\nexport default function getNodeName(element: ?Node): ?string {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}\n","// @flow\nimport getWindow from './getWindow';\n\nexport default function getComputedStyle(\n  element: Element\n): CSSStyleDeclaration {\n  return getWindow(element).getComputedStyle(element);\n}\n","// @flow\nimport type { SideObject } from '../types';\nimport getComputedStyle from './getComputedStyle';\nimport { isHTMLElement } from './instanceOf';\n\nfunction toNumber(cssValue: string): number {\n  return parseFloat(cssValue) || 0;\n}\n\nexport default function getBorders(element: Element): SideObject {\n  const computedStyle = isHTMLElement(element) ? getComputedStyle(element) : {};\n\n  return {\n    top: toNumber(computedStyle.borderTopWidth),\n    right: toNumber(computedStyle.borderRightWidth),\n    bottom: toNumber(computedStyle.borderBottomWidth),\n    left: toNumber(computedStyle.borderLeftWidth),\n  };\n}\n","// @flow\nimport type { Rect, VirtualElement, Offsets } from '../types';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport getNodeScroll from './getNodeScroll';\nimport getNodeName from './getNodeName';\nimport getBorders from './getBorders';\nimport { isHTMLElement } from './instanceOf';\n\n// offsets without `border`\nfunction getInnerOffsets(offsetParent: Element): Offsets {\n  const rect = getBoundingClientRect(offsetParent);\n  const borders = getBorders(offsetParent);\n\n  return {\n    x: rect.x + borders.left,\n    y: rect.y + borders.top,\n  };\n}\n\n// Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\nexport default function getCompositeRect(\n  elementOrVirtualElement: Element | VirtualElement,\n  offsetParent: Element,\n  isFixed: boolean = false\n): Rect {\n  const rect = getBoundingClientRect(elementOrVirtualElement);\n\n  let scroll = { scrollLeft: 0, scrollTop: 0 };\n  let offsets = { x: 0, y: 0 };\n\n  if (!isFixed) {\n    if (getNodeName(offsetParent) !== 'body') {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      offsets = getInnerOffsets(offsetParent);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height,\n  };\n}\n","// @flow\nimport getWindowScroll from './getWindowScroll';\nimport getWindow from './getWindow';\nimport { isHTMLElement } from './instanceOf';\nimport getHTMLElementScroll from './getHTMLElementScroll';\n\nexport default function getNodeScroll(node: Node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\n","// @flow\n\nexport default function getHTMLElementScroll(element: HTMLElement) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop,\n  };\n}\n","// @flow\nimport type { Rect } from '../types';\n\n// Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn't take into account transforms.\nexport default function getLayoutRect(element: HTMLElement): Rect {\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: element.offsetWidth,\n    height: element.offsetHeight,\n  };\n}\n","// @flow\nimport getNodeName from './getNodeName';\n\nexport default function getParentNode(element: Node | ShadowRoot): Node {\n  if (getNodeName(element) === 'html') {\n    return element;\n  }\n\n  return (\n    element.parentNode || // DOM Element detected\n    // $FlowFixMe: need a better way to handle this...\n    element.host || // ShadowRoot detected\n    document.ownerDocument || // Fallback to ownerDocument if available\n    document.documentElement // Or to documentElement if everything else fails\n  );\n}\n","// @flow\nimport getScrollParent from './getScrollParent';\nimport getParentNode from './getParentNode';\nimport getNodeName from './getNodeName';\nimport getWindow from './getWindow';\n\nexport default function listScrollParents(\n  element: Node,\n  list: Array<Element> = []\n): Array<Element> {\n  const scrollParent = getScrollParent(element);\n  const isBody = getNodeName(scrollParent) === 'body';\n  const target = isBody ? getWindow(scrollParent) : scrollParent;\n  const updatedList = list.concat(target);\n\n  return isBody\n    ? updatedList\n    : updatedList.concat(listScrollParents(getParentNode(target)));\n}\n","// @flow\nimport getParentNode from './getParentNode';\nimport getComputedStyle from './getComputedStyle';\nimport getNodeName from './getNodeName';\nimport { isHTMLElement } from './instanceOf';\n\nexport default function getScrollParent(node: Node): HTMLElement {\n  if (['html', 'body', '#document'].includes(getNodeName(node))) {\n    // $FlowFixMe: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node)) {\n    // Firefox wants us to check `-x` and `-y` variations as well\n    const { overflow, overflowX, overflowY } = getComputedStyle(node);\n\n    if (/auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX)) {\n      return node;\n    }\n  }\n\n  return getScrollParent(getParentNode(node));\n}\n","// @flow\nimport getWindow from './getWindow';\nimport getNodeName from './getNodeName';\nimport getComputedStyle from './getComputedStyle';\nimport { isHTMLElement } from './instanceOf';\nimport isTableElement from './isTableElement';\n\n// https://stackoverflow.com/a/9851769/2059996\nconst isFirefox = () => typeof window.InstallTrigger !== 'undefined';\n\nfunction getTrueOffsetParent(element: Element): ?Element {\n  let offsetParent;\n\n  if (\n    !isHTMLElement(element) ||\n    !(offsetParent = element.offsetParent) ||\n    // https://github.com/popperjs/popper.js/issues/837\n    (isFirefox() && getComputedStyle(offsetParent).position === 'fixed')\n  ) {\n    return null;\n  }\n\n  return offsetParent;\n}\n\nexport default function getOffsetParent(element: Element) {\n  const window = getWindow(element);\n\n  let offsetParent = getTrueOffsetParent(element);\n\n  // Find the nearest non-table offsetParent\n  while (offsetParent && isTableElement(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (\n    offsetParent &&\n    getNodeName(offsetParent) === 'body' &&\n    getComputedStyle(offsetParent).position === 'static'\n  ) {\n    return window;\n  }\n\n  return offsetParent || window;\n}\n","// @flow\nimport getNodeName from './getNodeName';\n\nexport default function isTableElement(element: Element): boolean {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\n","// @flow\nimport type { Modifier } from '../types';\nimport { modifierPhases } from '../enums';\n\n// source: https://stackoverflow.com/questions/49875255\nfunction order(modifiers) {\n  const map = new Map();\n  const visited = new Set();\n  const result = [];\n\n  modifiers.forEach(modifier => {\n    map.set(modifier.name, modifier);\n  });\n\n  // On visiting object, check for its dependencies and visit them recursively\n  function sort(modifier: Modifier<any>) {\n    visited.add(modifier.name);\n\n    const requires = [\n      ...(modifier.requires || []),\n      ...(modifier.requiresIfExists || []),\n    ];\n\n    requires.forEach(dep => {\n      if (!visited.has(dep)) {\n        const depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n\n    result.push(modifier);\n  }\n\n  modifiers.forEach(modifier => {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n\n  return result;\n}\n\nexport default function orderModifiers(\n  modifiers: Array<Modifier<any>>\n): Array<Modifier<any>> {\n  // order based on dependencies\n  const orderedModifiers = order(modifiers);\n\n  // order based on phase\n  return modifierPhases.reduce((acc, phase) => {\n    return acc.concat(\n      orderedModifiers.filter(modifier => modifier.phase === phase)\n    );\n  }, []);\n}\n","// @flow\n\nexport default function debounce<T>(fn: Function): () => Promise<T> {\n  let pending;\n  return () => {\n    if (!pending) {\n      pending = new Promise<T>(resolve => {\n        Promise.resolve().then(() => {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}\n","// @flow\nimport { type BasePlacement, type Placement, auto } from '../enums';\n\nexport default function getBasePlacement(\n  placement: Placement | typeof auto\n): BasePlacement {\n  return (placement.split('-')[0]: any);\n}\n","// @flow\nimport type {\n  State,\n  Options,\n  Modifier,\n  Instance,\n  VirtualElement,\n} from './types';\nimport getCompositeRect from './dom-utils/getCompositeRect';\nimport getLayoutRect from './dom-utils/getLayoutRect';\nimport listScrollParents from './dom-utils/listScrollParents';\nimport getOffsetParent from './dom-utils/getOffsetParent';\nimport getComputedStyle from './dom-utils/getComputedStyle';\nimport orderModifiers from './utils/orderModifiers';\nimport debounce from './utils/debounce';\nimport validateModifiers from './utils/validateModifiers';\nimport uniqueBy from './utils/uniqueBy';\nimport getBasePlacement from './utils/getBasePlacement';\nimport { isElement } from './dom-utils/instanceOf';\nimport { auto } from './enums';\n\nexport * from './types';\nexport * from './enums';\n\nconst INVALID_ELEMENT_ERROR =\n  'Popper: Invalid reference or popper argument provided to Popper, they must be either a valid DOM element, virtual element, or a jQuery-wrapped DOM element.';\nconst INFINITE_LOOP_ERROR =\n  'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\n\nconst DEFAULT_OPTIONS: Options = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute',\n};\n\ntype PopperGeneratorArgs = {\n  defaultModifiers?: Array<Modifier<any>>,\n  defaultOptions?: $Shape<Options>,\n};\n\nfunction areValidElements(...args: Array<any>): boolean {\n  return !args.some(\n    element => !(element && typeof element.getBoundingClientRect === 'function')\n  );\n}\n\nexport function popperGenerator(generatorOptions: PopperGeneratorArgs = {}) {\n  const {\n    defaultModifiers = [],\n    defaultOptions = DEFAULT_OPTIONS,\n  } = generatorOptions;\n\n  return function createPopper(\n    reference: Element | VirtualElement,\n    popper: HTMLElement,\n    options: $Shape<Options> = defaultOptions\n  ): Instance {\n    let state: $Shape<State> = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: { ...DEFAULT_OPTIONS, ...defaultOptions },\n      modifiersData: {},\n      elements: {\n        reference,\n        popper,\n      },\n      attributes: {},\n      styles: {},\n    };\n\n    let effectCleanupFns: Array<() => void> = [];\n    let isDestroyed = false;\n\n    const instance = {\n      state,\n      setOptions(options) {\n        cleanupModifierEffects();\n\n        state.options = {\n          ...defaultOptions,\n          ...state.options,\n          ...options,\n        };\n\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : [],\n          popper: listScrollParents(popper),\n        };\n\n        // Orders the modifiers based on their dependencies and `phase`\n        // properties\n        const orderedModifiers = orderModifiers([\n          ...state.options.modifiers.filter(\n            modifier =>\n              !defaultModifiers.find(({ name }) => name === modifier.name)\n          ),\n          ...defaultModifiers.map(defaultModifier => ({\n            ...defaultModifier,\n            ...state.options.modifiers.find(\n              ({ name }) => name === defaultModifier.name\n            ),\n          })),\n        ]);\n\n        // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n        if (__DEV__) {\n          const modifiers = uniqueBy(\n            [...orderedModifiers, ...state.options.modifiers],\n            ({ name }) => name\n          );\n\n          validateModifiers(modifiers);\n\n          if (getBasePlacement(state.options.placement) === auto) {\n            const flipModifier = orderedModifiers.find(\n              ({ name }) => name === 'flip'\n            );\n\n            if (!flipModifier) {\n              console.error(\n                [\n                  'Popper: \"auto\" placements require the \"flip\" modifier be',\n                  'present and enabled to work.',\n                ].join(' ')\n              );\n            }\n          }\n\n          const {\n            marginTop,\n            marginRight,\n            marginBottom,\n            marginLeft,\n          } = getComputedStyle(popper);\n\n          // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we'll warn the consumer\n          if (\n            [marginTop, marginRight, marginBottom, marginLeft].some(margin =>\n              parseFloat(margin)\n            )\n          ) {\n            console.warn(\n              [\n                'Popper: CSS \"margin\" styles cannot be used to apply padding',\n                'between the popper and its reference element or boundary.',\n                'To replicate margin, use the `offset` modifier, as well as',\n                'the `padding` option in the `preventOverflow` and `flip`',\n                'modifiers.',\n              ].join(' ')\n            );\n          }\n        }\n\n        // Strip out disabled modifiers\n        state.orderedModifiers = orderedModifiers.filter(m => m.enabled);\n\n        runModifierEffects();\n\n        return instance.update();\n      },\n\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        const { reference, popper } = state.elements;\n\n        // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n        if (!areValidElements(reference, popper)) {\n          if (__DEV__) {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n          return;\n        }\n\n        // Store the reference and popper rects to be read by modifiers\n        state.rects = {\n          reference: getCompositeRect(\n            reference,\n            getOffsetParent(popper),\n            state.options.strategy === 'fixed'\n          ),\n          popper: getLayoutRect(popper),\n        };\n\n        // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n        state.reset = false;\n\n        state.placement = state.options.placement;\n\n        // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n        state.orderedModifiers.forEach(\n          modifier =>\n            (state.modifiersData[modifier.name] = {\n              ...modifier.data,\n            })\n        );\n\n        let __debug_loops__ = 0;\n        for (let index = 0; index < state.orderedModifiers.length; index++) {\n          if (__DEV__) {\n            __debug_loops__ += 1;\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          const { fn, options = {}, name } = state.orderedModifiers[index];\n\n          if (typeof fn === 'function') {\n            state = fn({ state, options, name, instance }) || state;\n          }\n        }\n      },\n\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce<$Shape<State>>(\n        () =>\n          new Promise<$Shape<State>>(resolve => {\n            instance.forceUpdate();\n            resolve(state);\n          })\n      ),\n\n      destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      },\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (__DEV__) {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n      return instance;\n    }\n\n    instance.setOptions(options).then(state => {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    });\n\n    // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(({ name, options = {}, effect }) => {\n        if (typeof effect === 'function') {\n          const cleanupFn = effect({ state, name, instance, options });\n          const noopFn = () => {};\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(fn => fn());\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\n\nexport const createPopper = popperGenerator();\n","// @flow\nimport type { Placement } from '../enums';\n\nexport default function getMainAxisFromPlacement(\n  placement: Placement\n): 'x' | 'y' {\n  return ['top', 'bottom'].includes(placement) ? 'x' : 'y';\n}\n","// @flow\nimport getBasePlacement from './getBasePlacement';\nimport getVariation from './getVariation';\nimport getMainAxisFromPlacement from './getMainAxisFromPlacement';\nimport type {\n  Rect,\n  PositioningStrategy,\n  Offsets,\n  ClientRectObject,\n} from '../types';\nimport { top, right, bottom, left, start, end, type Placement } from '../enums';\n\nexport default function computeOffsets({\n  reference,\n  element,\n  placement,\n}: {\n  reference: Rect | ClientRectObject,\n  element: Rect | ClientRectObject,\n  strategy: PositioningStrategy,\n  placement?: Placement,\n}): Offsets {\n  const basePlacement = placement ? getBasePlacement(placement) : null;\n  const variation = placement ? getVariation(placement) : null;\n  const commonX = reference.x + reference.width / 2 - element.width / 2;\n  const commonY = reference.y + reference.height / 2 - element.height / 2;\n\n  let offsets;\n  switch (basePlacement) {\n    case top:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height,\n      };\n      break;\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height,\n      };\n      break;\n    case right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY,\n      };\n      break;\n    case left:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY,\n      };\n      break;\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y,\n      };\n  }\n\n  const mainAxis = basePlacement\n    ? getMainAxisFromPlacement(basePlacement)\n    : null;\n\n  if (mainAxis != null) {\n    const len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variation) {\n      case start:\n        offsets[mainAxis] =\n          Math.floor(offsets[mainAxis]) -\n          Math.floor(reference[len] / 2 - element[len] / 2);\n        break;\n      case end:\n        offsets[mainAxis] =\n          Math.floor(offsets[mainAxis]) +\n          Math.ceil(reference[len] / 2 - element[len] / 2);\n        break;\n      default:\n    }\n  }\n\n  return offsets;\n}\n","// @flow\nimport { type Variation, type Placement } from '../enums';\n\nexport default function getVariation(placement: Placement): ?Variation {\n  return (placement.split('-')[1]: any);\n}\n","// @flow\nexport const top: 'top' = 'top';\nexport const bottom: 'bottom' = 'bottom';\nexport const right: 'right' = 'right';\nexport const left: 'left' = 'left';\nexport const auto: 'auto' = 'auto';\nexport type BasePlacement =\n  | typeof top\n  | typeof bottom\n  | typeof right\n  | typeof left;\nexport const basePlacements: Array<BasePlacement> = [top, bottom, right, left];\n\nexport const start: 'start' = 'start';\nexport const end: 'end' = 'end';\nexport type Variation = typeof start | typeof end;\n\nexport const clippingParents: 'clippingParents' = 'clippingParents';\nexport const viewport: 'viewport' = 'viewport';\nexport type Boundary =\n  | HTMLElement\n  | Array<HTMLElement>\n  | typeof clippingParents;\nexport type RootBoundary = typeof viewport | 'document';\n\nexport const popper: 'popper' = 'popper';\nexport const reference: 'reference' = 'reference';\nexport type Context = typeof popper | typeof reference;\n\nexport type VariationPlacement =\n  | 'top-start'\n  | 'top-end'\n  | 'bottom-start'\n  | 'bottom-end'\n  | 'right-start'\n  | 'right-end'\n  | 'left-start'\n  | 'left-end';\nexport type AutoPlacement = 'auto' | 'auto-start' | 'auto-end';\nexport type ComputedPlacement = VariationPlacement | BasePlacement;\nexport type Placement = AutoPlacement | BasePlacement | VariationPlacement;\n\nexport const variationPlacements: Array<VariationPlacement> = basePlacements.reduce(\n  (acc: Array<VariationPlacement>, placement: BasePlacement) =>\n    acc.concat([(`${placement}-${start}`: any), (`${placement}-${end}`: any)]),\n  []\n);\nexport const placements: Array<Placement> = [...basePlacements, auto].reduce(\n  (\n    acc: Array<Placement>,\n    placement: BasePlacement | typeof auto\n  ): Array<Placement> =>\n    acc.concat([\n      placement,\n      (`${placement}-${start}`: any),\n      (`${placement}-${end}`: any),\n    ]),\n  []\n);\n\n// modifiers that need to read the DOM\nexport const beforeRead: 'beforeRead' = 'beforeRead';\nexport const read: 'read' = 'read';\nexport const afterRead: 'afterRead' = 'afterRead';\n// pure-logic modifiers\nexport const beforeMain: 'beforeMain' = 'beforeMain';\nexport const main: 'main' = 'main';\nexport const afterMain: 'afterMain' = 'afterMain';\n// modifier with the purpose to write to the DOM (or write into a framework state)\nexport const beforeWrite: 'beforeWrite' = 'beforeWrite';\nexport const write: 'write' = 'write';\nexport const afterWrite: 'afterWrite' = 'afterWrite';\nexport const modifierPhases: Array<ModifierPhases> = [\n  beforeRead,\n  read,\n  afterRead,\n  beforeMain,\n  main,\n  afterMain,\n  beforeWrite,\n  write,\n  afterWrite,\n];\n\nexport type ModifierPhases =\n  | typeof beforeRead\n  | typeof read\n  | typeof afterRead\n  | typeof beforeMain\n  | typeof main\n  | typeof afterMain\n  | typeof beforeWrite\n  | typeof write\n  | typeof afterWrite;\n","// @flow\nimport type {\n  PositioningStrategy,\n  Offsets,\n  Modifier,\n  ModifierArguments,\n  Rect,\n} from '../types';\nimport { type BasePlacement, top, left, right, bottom } from '../enums';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport getWindow from '../dom-utils/getWindow';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport getBasePlacement from '../utils/getBasePlacement';\n\ntype Options = {\n  gpuAcceleration: boolean,\n  adaptive: boolean,\n};\n\nconst unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto',\n};\n\n// Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\nfunction roundOffsets({ x, y }): Offsets {\n  const dpr = window.devicePixelRatio || 1;\n\n  return {\n    x: Math.round(x * dpr) / dpr || 0,\n    y: Math.round(y * dpr) / dpr || 0,\n  };\n}\n\nexport function mapToStyles({\n  popper,\n  popperRect,\n  placement,\n  offsets,\n  position,\n  gpuAcceleration,\n  adaptive,\n}: {\n  popper: HTMLElement,\n  popperRect: Rect,\n  placement: BasePlacement,\n  offsets: Offsets,\n  position: PositioningStrategy,\n  gpuAcceleration: boolean,\n  adaptive: boolean,\n}) {\n  let { x, y } = roundOffsets(offsets);\n\n  const hasX = offsets.hasOwnProperty('x');\n  const hasY = offsets.hasOwnProperty('y');\n\n  let sideX: string = left;\n  let sideY: string = top;\n\n  if (adaptive) {\n    let offsetParent = getOffsetParent(popper);\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n    }\n\n    if (placement === top) {\n      y = y - offsetParent.clientHeight + popperRect.height;\n      sideY = bottom;\n    }\n\n    if (placement === left) {\n      x = x - offsetParent.clientWidth + popperRect.width;\n      sideX = right;\n    }\n  }\n\n  const commonStyles = {\n    position,\n    ...(adaptive && unsetSides),\n  };\n\n  if (gpuAcceleration) {\n    return {\n      ...commonStyles,\n      [sideY]: hasY ? '0' : '',\n      [sideX]: hasX ? '0' : '',\n      // Layer acceleration can disable subpixel rendering which causes slightly\n      // blurry text on low PPI displays, so we want to use 2D transforms\n      // instead\n      transform:\n        (window.devicePixelRatio || 1) < 2\n          ? `translate(${x}px, ${y}px)`\n          : `translate3d(${x}px, ${y}px, 0)`,\n    };\n  }\n\n  return {\n    ...commonStyles,\n    [sideY]: hasY ? `${y}px` : '',\n    [sideX]: hasX ? `${x}px` : '',\n    transform: '',\n  };\n}\n\nfunction computeStyles({ state, options }: ModifierArguments<Options>) {\n  const { gpuAcceleration = true, adaptive = true } = options;\n\n  const commonStyles = {\n    placement: getBasePlacement(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration,\n  };\n\n  // popper offsets are always available\n  state.styles.popper = {\n    ...state.styles.popper,\n    ...mapToStyles({\n      ...commonStyles,\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive,\n    }),\n  };\n\n  // arrow offsets may not be available\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = {\n      ...state.styles.arrow,\n      ...mapToStyles({\n        ...commonStyles,\n        offsets: state.modifiersData.arrow,\n        position: 'absolute',\n        adaptive: false,\n      }),\n    };\n  }\n\n  state.attributes.popper = {\n    ...state.attributes.popper,\n    'data-popper-placement': state.placement,\n  };\n}\n\nexport default ({\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {},\n}: Modifier<Options>);\n","// @flow\nimport type { Placement } from '../enums';\n\nconst hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n\nexport default function getOppositePlacement(placement: Placement): Placement {\n  return (placement.replace(\n    /left|right|bottom|top/g,\n    matched => hash[matched]\n  ): any);\n}\n","// @flow\nimport type { Placement } from '../enums';\n\nconst hash = { start: 'end', end: 'start' };\n\nexport default function getOppositeVariationPlacement(\n  placement: Placement\n): Placement {\n  return (placement.replace(/start|end/g, matched => hash[matched]): any);\n}\n","// @flow\nexport default function contains(parent: Element, child: Element) {\n  // $FlowFixMe: hasOwnProperty doesn't seem to work in tests\n  const isShadow = Boolean(child.getRootNode && child.getRootNode().host);\n\n  // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  }\n  // then fallback to custom implementation with Shadow DOM support\n  else if (isShadow) {\n    let next = child;\n    do {\n      if (next && next.isSameNode(parent)) {\n        return true;\n      }\n      // $FlowFixMe: need a better way to handle this...\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  // Give up, the result is false\n  return false;\n}\n","// @flow\nimport type { Rect, ClientRectObject } from '../types';\n\nexport default function rectToClientRect(rect: Rect): ClientRectObject {\n  return {\n    ...rect,\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height,\n  };\n}\n","// @flow\nimport type { ClientRectObject } from '../types';\nimport type { Boundary, RootBoundary } from '../enums';\nimport { viewport } from '../enums';\nimport getViewportRect from './getViewportRect';\nimport getDocumentRect from './getDocumentRect';\nimport listScrollParents from './listScrollParents';\nimport getOffsetParent from './getOffsetParent';\nimport getDocumentElement from './getDocumentElement';\nimport getComputedStyle from './getComputedStyle';\nimport { isElement, isHTMLElement } from './instanceOf';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport getDecorations from './getDecorations';\nimport contains from './contains';\nimport rectToClientRect from '../utils/rectToClientRect';\n\nfunction getClientRectFromMixedType(\n  element: Element,\n  clippingParent: Element | RootBoundary\n): ClientRectObject {\n  return clippingParent === viewport\n    ? rectToClientRect(getViewportRect(element))\n    : isHTMLElement(clippingParent)\n    ? getBoundingClientRect(clippingParent)\n    : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n}\n\n// A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\nfunction getClippingParents(element: Element) {\n  const clippingParents = listScrollParents(element);\n  const canEscapeClipping = ['absolute', 'fixed'].includes(\n    getComputedStyle(element).position\n  );\n  const clipperElement =\n    canEscapeClipping && isHTMLElement(element)\n      ? getOffsetParent(element)\n      : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  }\n\n  return clippingParents.filter(clippingParent => {\n    return (\n      isElement(clippingParent) && contains(clippingParent, clipperElement)\n    );\n  });\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping parents\nexport default function getClippingRect(\n  element: Element,\n  boundary: Boundary,\n  rootBoundary: RootBoundary\n): ClientRectObject {\n  const mainClippingParents =\n    boundary === 'clippingParents'\n      ? getClippingParents(element)\n      : [].concat(boundary);\n  const clippingParents = [...mainClippingParents, rootBoundary];\n  const firstClippingParent = clippingParents[0];\n\n  const clippingRect = clippingParents.reduce((accRect, clippingParent) => {\n    const rect = getClientRectFromMixedType(element, clippingParent);\n    const decorations = getDecorations(\n      isHTMLElement(clippingParent)\n        ? clippingParent\n        : getDocumentElement(element)\n    );\n\n    accRect.top = Math.max(rect.top + decorations.top, accRect.top);\n    accRect.right = Math.min(rect.right - decorations.right, accRect.right);\n    accRect.bottom = Math.min(rect.bottom - decorations.bottom, accRect.bottom);\n    accRect.left = Math.max(rect.left + decorations.left, accRect.left);\n\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n\n  return clippingRect;\n}\n","// @flow\nimport getWindow from './getWindow';\n\nexport default function getViewportRect(element: Element) {\n  const win = getWindow(element);\n\n  return {\n    width: win.innerWidth,\n    height: win.innerHeight,\n    x: 0,\n    y: 0,\n  };\n}\n","// @flow\nimport type { Rect } from '../types';\nimport getCompositeRect from './getCompositeRect';\nimport getWindow from './getWindow';\nimport getDocumentElement from './getDocumentElement';\nimport getWindowScroll from './getWindowScroll';\n\nexport default function getDocumentRect(element: HTMLElement): Rect {\n  const win = getWindow(element);\n  const winScroll = getWindowScroll(element);\n  const documentRect = getCompositeRect(getDocumentElement(element), win);\n\n  documentRect.height = Math.max(documentRect.height, win.innerHeight);\n  documentRect.width = Math.max(documentRect.width, win.innerWidth);\n  documentRect.x = -winScroll.scrollLeft;\n  documentRect.y = -winScroll.scrollTop;\n\n  return documentRect;\n}\n","// @flow\nimport type { SideObject } from '../types';\nimport getBorders from './getBorders';\nimport getNodeName from './getNodeName';\nimport getWindow from './getWindow';\n\n// Borders + scrollbars\nexport default function getDecorations(element: HTMLElement): SideObject {\n  const borders = getBorders(element);\n  const win = getWindow(element);\n\n  let right = element.offsetWidth - element.clientWidth - borders.right;\n  let bottom = element.offsetHeight - element.clientHeight - borders.bottom;\n\n  if (getNodeName(element) === 'html') {\n    right = win.innerWidth - element.clientWidth;\n    bottom = win.innerHeight - element.clientHeight;\n  }\n\n  return {\n    top: borders.top,\n    right,\n    bottom,\n    left: borders.left,\n  };\n}\n","// @flow\nimport type { SideObject } from '../types';\nimport getFreshSideObject from './getFreshSideObject';\n\nexport default function mergePaddingObject(\n  paddingObject: $Shape<SideObject>\n): SideObject {\n  return {\n    ...getFreshSideObject(),\n    ...paddingObject,\n  };\n}\n","// @flow\nimport type { SideObject } from '../types';\n\nexport default function getFreshSideObject(): SideObject {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n  };\n}\n","// @flow\n\nexport default function expandToHashMap<\n  T: number | string | boolean,\n  K: string\n>(value: T, keys: Array<K>): { [key: string]: T } {\n  return keys.reduce((hashMap, key) => {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}\n","// @flow\nimport type { State, SideObject, Padding } from '../types';\nimport type { Placement, Boundary, RootBoundary, Context } from '../enums';\nimport getBoundingClientRect from '../dom-utils/getBoundingClientRect';\nimport getClippingRect from '../dom-utils/getClippingRect';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport computeOffsets from './computeOffsets';\nimport rectToClientRect from './rectToClientRect';\nimport {\n  clippingParents,\n  reference,\n  popper,\n  bottom,\n  top,\n  right,\n  basePlacements,\n  viewport,\n} from '../enums';\nimport { isElement } from '../dom-utils/instanceOf';\nimport mergePaddingObject from './mergePaddingObject';\nimport expandToHashMap from './expandToHashMap';\n\ntype Options = {\n  placement: Placement,\n  boundary: Boundary,\n  rootBoundary: RootBoundary,\n  elementContext: Context,\n  altBoundary: boolean,\n  padding: Padding,\n};\n\nexport default function detectOverflow(\n  state: State,\n  options: $Shape<Options> = {}\n): SideObject {\n  const {\n    placement = state.placement,\n    boundary = clippingParents,\n    rootBoundary = viewport,\n    elementContext = popper,\n    altBoundary = false,\n    padding = 0,\n  } = options;\n\n  const paddingObject = mergePaddingObject(\n    typeof padding !== 'number'\n      ? padding\n      : expandToHashMap(padding, basePlacements)\n  );\n\n  const altContext = elementContext === popper ? reference : popper;\n\n  const referenceElement = state.elements.reference;\n  const popperRect = state.rects.popper;\n  const element = state.elements[altBoundary ? altContext : elementContext];\n\n  const clippingClientRect = getClippingRect(\n    isElement(element) ? element : getDocumentElement(state.elements.popper),\n    boundary,\n    rootBoundary\n  );\n  const referenceClientRect = getBoundingClientRect(referenceElement);\n\n  const popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement,\n  });\n\n  const popperClientRect = rectToClientRect({\n    ...popperRect,\n    ...popperOffsets,\n  });\n\n  const elementClientRect =\n    elementContext === popper ? popperClientRect : referenceClientRect;\n\n  // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n  const overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom:\n      elementClientRect.bottom -\n      clippingClientRect.bottom +\n      paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right:\n      elementClientRect.right - clippingClientRect.right + paddingObject.right,\n  };\n\n  const offsetData = state.modifiersData.offset;\n\n  // Offsets can be applied only to the popper element\n  if (elementContext === popper && offsetData) {\n    const offset = offsetData[placement];\n\n    Object.keys(overflowOffsets).forEach(key => {\n      const multiply = [right, bottom].includes(key) ? 1 : -1;\n      const axis = [top, bottom].includes(key) ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}\n","// @flow\nimport type {\n  ModifierArguments,\n  Modifier,\n  Rect,\n  Options,\n  SideObject,\n  Offsets,\n} from '../types';\nimport { top, bottom, left, right } from '../enums';\nimport detectOverflow from '../utils/detectOverflow';\n\nfunction getSideOffsets(\n  overflow: SideObject,\n  rect: Rect,\n  preventedOffsets: Offsets = { x: 0, y: 0 }\n): SideObject {\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x,\n  };\n}\n\nfunction isAnySideFullyClipped(overflow: SideObject): boolean {\n  return [top, right, bottom, left].some(side => overflow[side] >= 0);\n}\n\nfunction hide({ state, name }: ModifierArguments<Options>) {\n  const referenceRect = state.rects.reference;\n  const popperRect = state.rects.popper;\n  const preventedOffsets = state.modifiersData.preventOverflow;\n\n  const referenceOverflow = detectOverflow(state, {\n    elementContext: 'reference',\n  });\n  const popperAltOverflow = detectOverflow(state, {\n    altBoundary: true,\n  });\n\n  const referenceClippingOffsets = getSideOffsets(\n    referenceOverflow,\n    referenceRect\n  );\n  const popperEscapeOffsets = getSideOffsets(\n    popperAltOverflow,\n    popperRect,\n    preventedOffsets\n  );\n\n  const isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  const hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n\n  state.modifiersData[name] = {\n    referenceClippingOffsets,\n    popperEscapeOffsets,\n    isReferenceHidden,\n    hasPopperEscaped,\n  };\n\n  state.attributes.popper = {\n    ...state.attributes.popper,\n    'data-popper-reference-hidden': isReferenceHidden,\n    'data-popper-escaped': hasPopperEscaped,\n  };\n}\n\nexport default ({\n  name: 'hide',\n  enabled: true,\n  phase: 'main',\n  requiresIfExists: ['preventOverflow'],\n  fn: hide,\n}: Modifier<Options>);\n","// @flow\nimport type { ModifierArguments, Modifier } from '../types';\nimport getWindow from '../dom-utils/getWindow';\n\ntype Options = {\n  scroll: boolean,\n  resize: boolean,\n};\n\nconst passive = { passive: true };\n\nfunction effect({ state, instance, options }: ModifierArguments<Options>) {\n  const { scroll = true, resize = true } = options;\n\n  const window = getWindow(state.elements.popper);\n  const scrollParents = [\n    ...state.scrollParents.reference,\n    ...state.scrollParents.popper,\n  ];\n\n  if (scroll) {\n    scrollParents.forEach(scrollParent => {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return () => {\n    if (scroll) {\n      scrollParents.forEach(scrollParent => {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n}\n\nexport default ({\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: () => {},\n  effect,\n  data: {},\n}: Modifier<Options>);\n","// @flow\nimport { popperGenerator } from './index';\nimport eventListeners from './modifiers/eventListeners';\nimport popperOffsets from './modifiers/popperOffsets';\nimport computeStyles from './modifiers/computeStyles';\nimport applyStyles from './modifiers/applyStyles';\nimport offset from './modifiers/offset';\nimport flip from './modifiers/flip';\nimport preventOverflow from './modifiers/preventOverflow';\nimport arrow from './modifiers/arrow';\nimport hide from './modifiers/hide';\n\nconst defaultModifiers = [\n  eventListeners,\n  popperOffsets,\n  computeStyles,\n  applyStyles,\n  offset,\n  flip,\n  preventOverflow,\n  arrow,\n  hide,\n];\n\nconst createPopper = popperGenerator({ defaultModifiers });\n\n// eslint-disable-next-line import/no-unused-modules\nexport { createPopper, popperGenerator, defaultModifiers };\n","// @flow\nimport type { ModifierArguments, Modifier } from '../types';\nimport computeOffsets from '../utils/computeOffsets';\n\nfunction popperOffsets({ state, name }: ModifierArguments<{||}>) {\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement,\n  });\n}\n\nexport default ({\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {},\n}: Modifier<{||}>);\n","// @flow\nimport type { Modifier, ModifierArguments } from '../types';\nimport getNodeName from '../dom-utils/getNodeName';\nimport { isHTMLElement } from '../dom-utils/instanceOf';\n\n// This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles({ state }: ModifierArguments<{||}>) {\n  Object.keys(state.elements).forEach(name => {\n    const style = state.styles[name] || {};\n\n    const attributes = state.attributes[name] || {};\n    const element = state.elements[name];\n\n    // arrow is optional + virtual elements\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    }\n\n    // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe\n    Object.assign(element.style, style);\n\n    Object.entries(attributes).forEach(([name, value]: [string, any]) => {\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction effect({ state }: ModifierArguments<{||}>) {\n  const initialStyles = {\n    position: 'absolute',\n    left: '0',\n    top: '0',\n    margin: '0',\n  };\n\n  Object.assign(state.elements.popper.style, initialStyles);\n\n  return () => {\n    Object.keys(state.elements).forEach(name => {\n      const element = state.elements[name];\n      const styleProperties = Object.keys(\n        state.styles.hasOwnProperty(name)\n          ? { ...state.styles[name] }\n          : initialStyles\n      );\n      const attributes = state.attributes[name] || {};\n\n      // Set all values to an empty string to unset them\n      const style = styleProperties.reduce(\n        (style, property) => ({\n          ...style,\n          [String(property)]: '',\n        }),\n        {}\n      );\n\n      // arrow is optional + virtual elements\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      }\n\n      // Flow doesn't support to extend this property, but it's the most\n      // effective way to apply styles to an HTMLElement\n      // $FlowFixMe\n      Object.assign(element.style, style);\n\n      Object.keys(attributes).forEach(attribute =>\n        element.removeAttribute(attribute)\n      );\n    });\n  };\n}\n\nexport default ({\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect,\n  requires: ['computeStyles'],\n}: Modifier<{||}>);\n","// @flow\nimport type { Placement } from '../enums';\nimport type { ModifierArguments, Modifier, Rect, Offsets } from '../types';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport { top, left, right, placements } from '../enums';\n\ntype OffsetsFunction = ({\n  popper: Rect,\n  reference: Rect,\n  placement: Placement,\n}) => [?number, ?number];\n\ntype Offset = OffsetsFunction | [?number, ?number];\n\ntype Options = {\n  offset: Offset,\n};\n\nexport function distanceAndSkiddingToXY(\n  placement: Placement,\n  rects: { popper: Rect, reference: Rect },\n  offset: Offset\n): Offsets {\n  const basePlacement = getBasePlacement(placement);\n  const invertDistance = [left, top].includes(basePlacement) ? -1 : 1;\n\n  let [skidding, distance] =\n    typeof offset === 'function'\n      ? offset({\n          ...rects,\n          placement,\n        })\n      : offset;\n\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n\n  return [left, right].includes(basePlacement)\n    ? { x: distance, y: skidding }\n    : { x: skidding, y: distance };\n}\n\nfunction offset({ state, options, name }: ModifierArguments<Options>) {\n  const { offset = [0, 0] } = options;\n\n  const data = placements.reduce((acc, placement) => {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n\n  const { x, y } = data[state.placement];\n\n  state.modifiersData.popperOffsets.x += x;\n  state.modifiersData.popperOffsets.y += y;\n\n  state.modifiersData[name] = data;\n}\n\nexport default ({\n  name: 'offset',\n  enabled: true,\n  phase: 'main',\n  requires: ['popperOffsets'],\n  fn: offset,\n}: Modifier<Options>);\n","// @flow\nimport type { Placement, Boundary, RootBoundary } from '../enums';\nimport type { ModifierArguments, Modifier, Padding } from '../types';\nimport getOppositePlacement from '../utils/getOppositePlacement';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getOppositeVariationPlacement from '../utils/getOppositeVariationPlacement';\nimport detectOverflow from '../utils/detectOverflow';\nimport computeAutoPlacement from '../utils/computeAutoPlacement';\nimport uniqueBy from '../utils/uniqueBy';\nimport { bottom, top, start, right, left, auto } from '../enums';\nimport getVariation from '../utils/getVariation';\n\ntype Options = {\n  fallbackPlacements: Array<Placement>,\n  padding: Padding,\n  boundary: Boundary,\n  rootBoundary: RootBoundary,\n  flipVariations: boolean,\n};\n\nfunction getExpandedFallbackPlacements(placement: Placement): Array<Placement> {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n\n  const oppositePlacement = getOppositePlacement(placement);\n\n  return [\n    getOppositeVariationPlacement(placement),\n    oppositePlacement,\n    getOppositeVariationPlacement(oppositePlacement),\n  ];\n}\n\nfunction flip({ state, options, name }: ModifierArguments<Options>) {\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  const {\n    fallbackPlacements: specifiedFallbackPlacements,\n    padding,\n    boundary,\n    rootBoundary,\n    flipVariations = true,\n  } = options;\n\n  const preferredPlacement = state.options.placement;\n  const basePlacement = getBasePlacement(preferredPlacement);\n  const isBasePlacement = basePlacement === preferredPlacement;\n\n  const fallbackPlacements =\n    specifiedFallbackPlacements ||\n    (isBasePlacement\n      ? [getOppositePlacement(preferredPlacement)]\n      : getExpandedFallbackPlacements(preferredPlacement));\n\n  const placements = uniqueBy(\n    [preferredPlacement, ...fallbackPlacements].reduce((acc, placement) => {\n      return getBasePlacement(placement) === auto\n        ? acc.concat(\n            computeAutoPlacement(state, {\n              placement,\n              boundary,\n              rootBoundary,\n              padding,\n              flipVariations,\n            })\n          )\n        : acc.concat(placement);\n    }, []),\n    placement => placement\n  );\n\n  const referenceRect = state.rects.reference;\n  const popperRect = state.rects.popper;\n\n  const checksMap: Map<string, Array<boolean>> = new Map();\n  let makeFallbackChecks = true;\n  let firstFittingPlacement = placements[0];\n\n  for (let i = 0; i < placements.length; i++) {\n    const placement = placements[i];\n    const basePlacement = getBasePlacement(placement);\n    const isStartVariation = getVariation(placement) === start;\n    const isVertical = [top, bottom].includes(basePlacement);\n    const len = isVertical ? 'width' : 'height';\n\n    const overflow = detectOverflow(state, {\n      placement,\n      boundary,\n      rootBoundary,\n      padding,\n    });\n\n    let mainVariationSide: any = isVertical\n      ? isStartVariation\n        ? right\n        : left\n      : isStartVariation\n      ? bottom\n      : top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    const altVariationSide: any = getOppositePlacement(mainVariationSide);\n\n    const checks = [\n      overflow[basePlacement] <= 0,\n      overflow[mainVariationSide] <= 0,\n      overflow[altVariationSide] <= 0,\n    ];\n\n    if (checks.every(check => check)) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases – research later\n    const numberOfChecks = flipVariations ? 3 : 1;\n\n    for (let i = numberOfChecks; i > 0; i--) {\n      const fittingPlacement = placements.find(placement => {\n        const checks = checksMap.get(placement);\n        if (checks) {\n          return checks.slice(0, i).every(check => check);\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        break;\n      }\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n}\n\nexport default ({\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: { _skip: false },\n}: Modifier<Options>);\n","// @flow\n\nexport default function uniqueBy<T>(arr: Array<T>, fn: T => any): Array<T> {\n  const identifiers = new Set();\n\n  return arr.filter(item => {\n    const identifier = fn(item);\n\n    if (!identifiers.has(identifier)) {\n      identifiers.add(identifier);\n      return true;\n    }\n  });\n}\n","// @flow\nimport type { State, Padding } from '../types';\nimport type {\n  Placement,\n  BasePlacement,\n  VariationPlacement,\n  Boundary,\n  RootBoundary,\n  ComputedPlacement,\n} from '../enums';\nimport getVariation from './getVariation';\nimport { variationPlacements, basePlacements } from '../enums';\nimport detectOverflow from './detectOverflow';\nimport getBasePlacement from './getBasePlacement';\n\ntype Options = {\n  placement: Placement,\n  padding: Padding,\n  boundary: Boundary,\n  rootBoundary: RootBoundary,\n  flipVariations: boolean,\n};\n\ntype OverflowsMap = {\n  [BasePlacement | VariationPlacement]: number,\n};\n\nexport default function computeAutoPlacement(\n  state: $Shape<State>,\n  options: Options = {}\n): Array<ComputedPlacement> {\n  const {\n    placement,\n    boundary,\n    rootBoundary,\n    padding,\n    flipVariations,\n  } = options;\n\n  const variation = getVariation(placement);\n\n  const placements = variation\n    ? flipVariations\n      ? variationPlacements\n      : variationPlacements.filter(placement => placement.includes(variation))\n    : basePlacements;\n\n  // $FlowFixMe: Flow seems to have problems with two array unions...\n  const overflows: OverflowsMap = placements.reduce((acc, placement) => {\n    acc[placement] = detectOverflow(state, {\n      placement,\n      boundary,\n      rootBoundary,\n      padding,\n    })[getBasePlacement(placement)];\n\n    return acc;\n  }, {});\n\n  return Object.keys(overflows).sort((a, b) => overflows[a] - overflows[b]);\n}\n","// @flow\nimport { top, left, right, bottom, start } from '../enums';\nimport type { Placement, Boundary, RootBoundary } from '../enums';\nimport type { Rect, ModifierArguments, Modifier, Padding } from '../types';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport getAltAxis from '../utils/getAltAxis';\nimport within from '../utils/within';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport detectOverflow from '../utils/detectOverflow';\nimport getVariation from '../utils/getVariation';\nimport getFreshSideObject from '../utils/getFreshSideObject';\n\ntype TetherOffset =\n  | (({\n      popper: Rect,\n      reference: Rect,\n      placement: Placement,\n    }) => number)\n  | number;\n\ntype Options = {\n  /* Prevents boundaries overflow on the main axis */\n  mainAxis: boolean,\n  /* Prevents boundaries overflow on the alternate axis */\n  altAxis: boolean,\n  /* The area to check the popper is overflowing in */\n  boundary: Boundary,\n  /* If the popper is not overflowing the main area, fallback to this one */\n  rootBoundary: RootBoundary,\n  /**\n   * Allows the popper to overflow from its boundaries to keep it near its\n   * reference element\n   */\n  tether: boolean,\n  /* Offsets when the `tether` option should activate */\n  tetherOffset: TetherOffset,\n  /* Sets a padding to the provided boundary */\n  padding: Padding,\n};\n\nfunction preventOverflow({ state, options, name }: ModifierArguments<Options>) {\n  const {\n    mainAxis: checkMainAxis = true,\n    altAxis: checkAltAxis = false,\n    boundary,\n    rootBoundary,\n    padding,\n    tether = true,\n    tetherOffset = 0,\n  } = options;\n\n  const overflow = detectOverflow(state, { boundary, rootBoundary, padding });\n  const basePlacement = getBasePlacement(state.placement);\n  const variation = getVariation(state.placement);\n  const isBasePlacement = !variation;\n  const mainAxis = getMainAxisFromPlacement(basePlacement);\n  const altAxis = getAltAxis(mainAxis);\n  const popperOffsets = state.modifiersData.popperOffsets;\n  const referenceRect = state.rects.reference;\n  const popperRect = state.rects.popper;\n  const tetherOffsetValue =\n    typeof tetherOffset === 'function'\n      ? tetherOffset({\n          ...state.rects,\n          placement: state.placement,\n        })\n      : tetherOffset;\n\n  const data = { x: 0, y: 0 };\n\n  if (checkMainAxis) {\n    const mainSide = mainAxis === 'y' ? top : left;\n    const altSide = mainAxis === 'y' ? bottom : right;\n    const len = mainAxis === 'y' ? 'height' : 'width';\n    const offset = popperOffsets[mainAxis];\n\n    const min = popperOffsets[mainAxis] + overflow[mainSide];\n    const max = popperOffsets[mainAxis] - overflow[altSide];\n\n    const additive = tether ? -popperRect[len] / 2 : 0;\n\n    const minLen = variation === start ? referenceRect[len] : popperRect[len];\n    const maxLen = variation === start ? -popperRect[len] : -referenceRect[len];\n\n    // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n    const arrowElement = state.elements.arrow;\n    const arrowRect =\n      tether && arrowElement\n        ? getLayoutRect(arrowElement)\n        : { width: 0, height: 0 };\n    const arrowPaddingObject = state.modifiersData['arrow#persistent']\n      ? state.modifiersData['arrow#persistent'].padding\n      : getFreshSideObject();\n    const arrowPaddingMin = arrowPaddingObject[mainSide];\n    const arrowPaddingMax = arrowPaddingObject[altSide];\n\n    // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n    const arrowLen = within(\n      0,\n      Math.abs(referenceRect[len] - arrowRect[len]),\n      arrowRect[len]\n    );\n\n    const minOffset = isBasePlacement\n      ? referenceRect[len] / 2 -\n        additive -\n        arrowLen -\n        arrowPaddingMin -\n        tetherOffsetValue\n      : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n    const maxOffset = isBasePlacement\n      ? -referenceRect[len] / 2 +\n        additive +\n        arrowLen +\n        arrowPaddingMax +\n        tetherOffsetValue\n      : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n\n    const offsetModifierValue = state.modifiersData.offset\n      ? state.modifiersData.offset[state.placement][mainAxis]\n      : 0;\n    const tetherMin =\n      state.modifiersData.popperOffsets[mainAxis] +\n      minOffset -\n      offsetModifierValue;\n    const tetherMax =\n      state.modifiersData.popperOffsets[mainAxis] +\n      maxOffset -\n      offsetModifierValue;\n\n    const preventedOffset = within(\n      tether ? Math.min(min, tetherMin) : min,\n      offset,\n      tether ? Math.max(max, tetherMax) : max\n    );\n\n    state.modifiersData.popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    const mainSide = mainAxis === 'x' ? top : left;\n    const altSide = mainAxis === 'x' ? bottom : right;\n    const offset = popperOffsets[altAxis];\n\n    const min = offset + overflow[mainSide];\n    const max = offset - overflow[altSide];\n\n    const preventedOffset = within(min, offset, max);\n\n    state.modifiersData.popperOffsets[altAxis] = preventedOffset;\n    data[altAxis] = preventedOffset - offset;\n  }\n\n  state.modifiersData[name] = data;\n}\n\nexport default ({\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset'],\n}: Modifier<Options>);\n","// @flow\n\nexport default function getAltAxis(axis: 'x' | 'y'): 'x' | 'y' {\n  return axis === 'x' ? 'y' : 'x';\n}\n","// @flow\n\nexport default function within(\n  min: number,\n  value: number,\n  max: number\n): number {\n  return Math.max(min, Math.min(value, max));\n}\n","// @flow\nimport type { Modifier, ModifierArguments, Padding } from '../types';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport contains from '../dom-utils/contains';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport within from '../utils/within';\nimport mergePaddingObject from '../utils/mergePaddingObject';\nimport expandToHashMap from '../utils/expandToHashMap';\nimport { left, right, basePlacements, top, bottom } from '../enums';\n\ntype Options = {\n  element: HTMLElement | string,\n  padding: Padding,\n};\n\nfunction arrow({ state, name }: ModifierArguments<Options>) {\n  const arrowElement = state.elements.arrow;\n  const popperOffsets = state.modifiersData.popperOffsets;\n  const basePlacement = getBasePlacement(state.placement);\n  const axis = getMainAxisFromPlacement(basePlacement);\n  const isVertical = [left, right].includes(basePlacement);\n  const len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement) {\n    return;\n  }\n\n  const paddingObject = state.modifiersData[`${name}#persistent`].padding;\n  const arrowRect = getLayoutRect(arrowElement);\n  const minProp = axis === 'y' ? top : left;\n  const maxProp = axis === 'y' ? bottom : right;\n\n  const endDiff =\n    state.rects.reference[len] +\n    state.rects.reference[axis] -\n    popperOffsets[axis] -\n    state.rects.popper[len];\n  const startDiff = popperOffsets[axis] - state.rects.reference[axis];\n\n  const centerToReference = endDiff / 2 - startDiff / 2;\n\n  // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n  const center = within(\n    paddingObject[minProp],\n    state.rects.popper[len] / 2 - arrowRect[len] / 2 + centerToReference,\n    state.rects.popper[len] - arrowRect[len] - paddingObject[maxProp]\n  );\n\n  // Prevents breaking syntax highlighting...\n  const axisProp: string = axis;\n  state.modifiersData[name] = { [axisProp]: center };\n}\n\nfunction effect({ state, options, name }: ModifierArguments<Options>) {\n  let { element: arrowElement = '[data-popper-arrow]', padding = 0 } = options;\n\n  // CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (!contains(state.elements.popper, arrowElement)) {\n    if (__DEV__) {\n      console.error(\n        [\n          'Popper: \"arrow\" modifier\\'s `element` must be a child of the popper',\n          'element.',\n        ].join(' ')\n      );\n    }\n\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n  state.modifiersData[`${name}#persistent`] = {\n    padding: mergePaddingObject(\n      typeof padding !== 'number'\n        ? padding\n        : expandToHashMap(padding, basePlacements)\n    ),\n  };\n}\n\nexport default ({\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow'],\n}: Modifier<Options>);\n"],"names":["getBoundingClientRect","element","width","rect","height","top","right","bottom","left","x","y","getWindow","node","ownerDocument","window","getWindowScroll","scrollLeft","win","scrollTop","isElement","isHTMLElement","getNodeName","getComputedStyle","getBorders","computedStyle","parseFloat","getCompositeRect","elementOrVirtualElement","offsetParent","isFixed","scroll","f","e","borders","offsets","getLayoutRect","getParentNode","document","listScrollParents","list","scrollParent","getScrollParent","isBody","target","updatedList","getTrueOffsetParent","getOffsetParent","order","modifiers","map","Map","visited","Set","result","modifier","dep","depModifier","sort","debounce","fn","pending","Promise","resolve","undefined","getBasePlacement","placement","areValidElements","args","popperGenerator","generatorOptions","defaultModifiers","defaultOptions","DEFAULT_OPTIONS","reference","popper","options","effectCleanupFns","state","orderedModifiers","modifiersData","elements","attributes","styles","isDestroyed","instance","setOptions","cleanupModifierEffects","orderModifiers","acc","phase","defaultModifier","m","name","cleanupFn","effect","noopFn","forceUpdate","index","update","destroy","getMainAxisFromPlacement","computeOffsets","basePlacement","commonX","commonY","mainAxis","len","variation","start","Math","end","mapToStyles","popperRect","position","gpuAcceleration","adaptive","dpr","hasX","sideX","sideY","commonStyles","unsetSides","hasY","getOppositePlacement","matched","getOppositeVariationPlacement","contains","parent","child","isShadow","next","rectToClientRect","getClientRectFromMixedType","clippingParent","viewport","documentRect","winScroll","getClippingRect","boundary","rootBoundary","mainClippingParents","getClippingParents","clippingParents","clipperElement","accRect","decorations","clippingRect","mergePaddingObject","paddingObject","expandToHashMap","value","keys","hashMap","key","detectOverflow","altBoundary","padding","basePlacements","referenceElement","elementContext","strategy","popperOffsets","popperClientRect","referenceClientRect","overflowOffsets","clippingClientRect","elementClientRect","offsetData","offset","multiply","axis","overflow","preventedOffsets","isAnySideFullyClipped","side","variationPlacements","placements","auto","modifierPhases","passive","hash","eventListeners","enabled","resize","scrollParents","data","popperOffsets$1","computeStyles$1","computeStyles","applyStyles$1","applyStyles","style","Object","effect$1","initialStyles","margin","styleProperties","property","String","attribute","requires","offset$1","distanceAndSkiddingToXY","invertDistance","rects","distance","skidding","flip$1","flip","specifiedFallbackPlacements","flipVariations","preferredPlacement","getExpandedFallbackPlacements","oppositePlacement","uniqueBy","arr","identifiers","item","identifier","fallbackPlacements","computeAutoPlacement","overflows","a","b","checksMap","firstFittingPlacement","i","isStartVariation","isVertical","mainVariationSide","altVariationSide","check","checks","makeFallbackChecks","fittingPlacement","requiresIfExists","_skip","preventOverflow$1","preventOverflow","checkMainAxis","tetherOffset","isBasePlacement","referenceRect","tetherOffsetValue","mainSide","altSide","min","max","additive","tether","minLen","arrowElement","arrowPaddingObject","arrowRect","arrowLen","arrowPaddingMin","offsetModifierValue","arrowPaddingMax","maxLen","tetherMin","tetherMax","preventedOffset","checkAltAxis","altAxis","arrow$1","arrow","center","effect$2","hide$1","hide","referenceOverflow","popperAltOverflow","getSideOffsets","referenceClippingOffsets","popperEscapeOffsets","isReferenceHidden","hasPopperEscaped","createPopper"],"mappings":"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"}
